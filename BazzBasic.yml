schema_version: "1.1"
context: "BazzBasic BASIC Interpreter project"

Dev_lang:
 - C# .NET10
Project_name:
  - BazzBasic
Project_url:
  - https://github.com/EkBass/BazzBasic
Editing:
  - Use "Filesystem" MCP or "Desktop Commander" MCP to enter the project folder and to edit code.
Project_root_path:
- C:\Users\ekvir\source\repos\BazzBasic
BazzBasic_wiki:
- "C:\Users\ekvir\source\repos\BazzBasic.wiki"
BazzBasic_examples:
- C:\Users\ekvir\source\repos\BazzBasic\examples


project:
  name: "BazzBasic"
  language: "C# .NET 10"
  type: "BASIC Interpreter with integrated IDE"
  root: "C:\\Users\\ekvir\\source\\repos\\BazzBasic"
  
architecture:
  pipeline: "Lexer → Parser → Interpreter"
  execution_model: "Token-based direct interpretation"
  design_philosophy: "Strict semantics, early error detection, O(1) lookups"
  
  dual_mode_operation:
    description: "Single executable operates in two modes"
    ide_mode:
      trigger: "Run without arguments: bazzbasic.exe"
      behavior: "Launches WinForms IDE with Scintilla editor"
      thread: "STA thread required for dialogs"
      console: "Detached via FreeConsole()"
    interpreter_mode:
      trigger: "Run with file argument: bazzbasic.exe file.bas"
      behavior: "Executes BASIC program in console"
      console: "Attached, shows output"
  
  phases:
    lexer:
      purpose: "Source text → Token stream"
      file: "src/Lexer/Lexer.cs"
      key_features:
        - "O(1) keyword lookup via Dictionary<string, TokenType>"
        - "Numbered token system (TOK_PRINT = 15, etc)"
        - "Case-insensitive keyword matching"
        - "Escape sequence handling in strings"
    
    parser:
      purpose: "Token validation and AST-like Value objects"
      file: "src/Parser/Value.cs"
      key_features:
        - "Tagged union: Value { Number | String }"
        - "Factory methods: Value.FromNumber(), Value.FromString()"
        - "No traditional AST - direct interpretation"
    
    interpreter:
      purpose: "Token stream → Execution"
      file: "src/Interpreter/Interpreter.cs"
      key_features:
        - "Partial class split by functionality"
        - "Recursive descent expression evaluator"
        - "Position-based token cursor (_pos)"
        - "Direct execution - no intermediate IR"

# ============================================================================
# Directory Structure & File Organization
# ============================================================================

directory_structure:
  source_files:
    ide:
      path: "src/IDE/"
      description: "Integrated Development Environment"
      files:
        - name: "MainForm.cs"
          contains: "Main IDE logic, file operations, editor management"
        - name: "MainForm.Designer.cs"
          contains: "UI layout, menus, tab control, status bar"
        - name: "FindReplaceDialog.cs"
          contains: "Find/Replace dialog with match case option"
        - name: "icon.png"
          contains: "Application icon (green background, yellow B)"
      
    lexer:
      path: "src/Lexer/"
      files:
        - name: "Lexer.cs"
          contains: "Main lexer, keyword dictionary, tokenization"
        - name: "TokenType.cs"
          contains: "All token type enums (TOK_*)"
          pattern: "enum TokenType { TOK_PRINT, TOK_IF, ... }"
    
    parser:
      path: "src/Parser/"
      files:
        - name: "Value.cs"
          contains: "Runtime value type (Number/String tagged union)"
          critical_methods:
            - "Value.FromNumber(double)"
            - "Value.FromString(string)"
            - "AsNumber() / AsString()"
    
    interpreter:
      path: "src/Interpreter/"
      strategy: "Partial class split by feature domain"
      files:
        - "Interpreter.cs": "Main loop, initialization, state"
        - "Interpreter.Expression.cs": "EvaluateExpression(), all functions"
        - "Interpreter.Control.cs": "IF/WHILE/FOR control flow"
        - "Interpreter.IO.cs": "PRINT, INPUT, CLS, COLOR, LOCATE"
        - "Interpreter.Math.cs": "SIN, COS, SQR, RND, etc"
        - "Interpreter.String.cs": "LEFT, MID, INSTR, TRIM, etc"
        - "Interpreter.Arrays.cs": "Array operations, HASKEY, DELKEY"
        - "Interpreter.Graphics.cs": "SCREEN, LINE, CIRCLE, PSET, shapes"
        - "Interpreter.Sound.cs": "LOADSOUND, SOUNDONCE, SOUNDREPEAT"
        - "Interpreter.Jump.cs": "GOTO, GOSUB, RETURN"
        - "Variables.cs": "Variable storage and scope management"
    
    graphics:
      path: "src/Graphics/"
      files:
        - "GraphicsManager.cs": "SDL2-based rendering"
    
    sound:
      path: "src/Sound/"
      files:
        - "SoundManager.cs": "NAudio-based audio playback"
    
    preprocessor:
      path: "src/Preprocessor/"
      files:
        - "Files related to INCLUDE directive handling"
    
    entry_point:
      path: "src/"
      files:
        - name: "Program.cs"
          contains: "Dual-mode entry point (IDE vs Interpreter)"
          key_logic: |
            if (args.Length == 0) → Launch IDE on STA thread
            else → Run interpreter with file argument
  
  test_files:
    path: "examples/"
    purpose: "Test .bas files for feature verification"

# ============================================================================
# IDE Architecture
# ============================================================================

ide_architecture:
  technology:
    framework: "Windows Forms (.NET 10)"
    editor: "Scintilla5.NET 5.6.0"
    threading: "STA thread required for file dialogs"
  
  main_components:
    MainForm:
      purpose: "Main IDE window"
      features:
        - "Tabbed multi-file editing with close buttons"
        - "Syntax highlighting for BazzBasic keywords"
        - "File operations (New, Open, Save, Save As)"
        - "Find/Replace functionality (Ctrl+F, Ctrl+H)"
        - "F5 to run current program"
        - "Line/column position in status bar"
      
    FindReplaceDialog:
      purpose: "Find and Replace dialog"
      features:
        - "Find Next (Enter or button)"
        - "Replace single occurrence"
        - "Replace All"
        - "Match case option"
        - "ESC to close"
      designer_note: "No lambdas in InitializeComponent - use WireEvents()"
    
    EditorTab:
      purpose: "Track state per tab"
      properties:
        - "TabPage reference"
        - "Scintilla Editor reference"
        - "FilePath (null if untitled)"
        - "IsModified flag"
  
  keyboard_shortcuts:
    file:
      "Ctrl+N": "New file"
      "Ctrl+O": "Open file"
      "Ctrl+S": "Save"
      "Ctrl+Shift+S": "Save As"
      "Ctrl+W": "Close tab"
    edit:
      "Ctrl+F": "Find"
      "Ctrl+H": "Replace"
      "F3": "Find Next"
    run:
      "F5": "Run program"
  
  run_behavior:
    method: "cmd /k to keep window open"
    reason: "Shows errors and supports INPUT command"
    command: 'cmd /k ""BazzBasic.exe" "file.bas""'

# ============================================================================
# Token System - Core Mechanism
# ============================================================================

token_system:
  paradigm: "Numbered enum for O(1) switch dispatch"
  
  token_definition_workflow:
    step_1:
      file: "src/Lexer/TokenType.cs"
      action: "Add enum value in appropriate section"
      example: |
        // Sound Keywords
        TOK_LOADSOUND,
        TOK_SOUNDONCE,
        TOK_SOUNDREPEAT,
    
    step_2:
      file: "src/Lexer/Lexer.cs"
      action: "Add to keyword dictionary"
      location: "Dictionary<string, TokenType> _keywords"
      example: |
        ["LOADSOUND"] = TokenType.TOK_LOADSOUND,
        ["SOUNDONCE"] = TokenType.TOK_SOUNDONCE,
    
    step_3:
      file: "src/Interpreter/Interpreter.Expression.cs OR Interpreter/*.cs"
      action: "Implement handler"
      example_function: |
        case TokenType.TOK_LOADSOUND:
            return EvaluateLoadSound();
      example_statement: |
        case TokenType.TOK_SOUNDONCE:
            ExecuteSoundOnce();
            break;
  
  token_categories:
    control_flow: "TOK_IF, TOK_WHILE, TOK_FOR, TOK_GOSUB, TOK_GOTO"
    io: "TOK_PRINT, TOK_INPUT, TOK_CLS, TOK_COLOR, TOK_LOCATE"
    graphics: "TOK_SCREEN, TOK_LINE, TOK_CIRCLE, TOK_PSET, TOK_PAINT"
    sound: "TOK_LOADSOUND, TOK_SOUNDONCE, TOK_SOUNDREPEAT"
    math_functions: "TOK_SIN, TOK_COS, TOK_SQR, TOK_ABS, TOK_RND"
    string_functions: "TOK_LEFT, TOK_MID, TOK_INSTR, TOK_LEN"
    operators: "TOK_PLUS, TOK_MINUS, TOK_MULTIPLY, TOK_EQUALS"
    literals: "TOK_NUMBER, TOK_STRING, TOK_VARIABLE, TOK_CONSTANT"

# ============================================================================
# Adding New Features - Complete Workflow
# ============================================================================

feature_addition_workflow:
  
  case_1_statement_command:
    description: "Adding a statement like SOUNDONCE (executes, returns nothing)"
    steps:
      - step: "Add token to TokenType.cs"
        file: "src/Lexer/TokenType.cs"
        code: "TOK_SOUNDONCE,"
      
      - step: "Register keyword in Lexer"
        file: "src/Lexer/Lexer.cs"
        code: '["SOUNDONCE"] = TokenType.TOK_SOUNDONCE,'
      
      - step: "Create handler method"
        file: "src/Interpreter/Interpreter.<Domain>.cs"
        code: |
          private void ExecuteSoundOnce()
          {
              _pos++; // Skip token
              Require(TokenType.TOK_LPAREN, "Expected '('");
              string soundId = EvaluateExpression().AsString();
              Require(TokenType.TOK_RPAREN, "Expected ')'");
              _soundManager.PlayOnce(soundId);
          }
      
      - step: "Add case to main interpreter loop"
        file: "src/Interpreter/Interpreter.cs"
        location: "ExecuteLine() switch statement"
        code: |
          case TokenType.TOK_SOUNDONCE:
              ExecuteSoundOnce();
              break;
  
  case_2_function:
    description: "Adding a function like LOADSOUND (returns a Value)"
    steps:
      - step: "Add token to TokenType.cs"
        file: "src/Lexer/TokenType.cs"
        code: "TOK_LOADSOUND,"
      
      - step: "Register keyword in Lexer"
        file: "src/Lexer/Lexer.cs"
        code: '["LOADSOUND"] = TokenType.TOK_LOADSOUND,'
      
      - step: "Create evaluation method"
        file: "src/Interpreter/Interpreter.<Domain>.cs"
        code: |
          private Value EvaluateLoadSound()
          {
              _pos++; // Skip token
              Require(TokenType.TOK_LPAREN, "Expected '('");
              string path = EvaluateExpression().AsString();
              Require(TokenType.TOK_RPAREN, "Expected ')'");
              string id = _soundManager.LoadSound(path);
              return Value.FromString(id);  // CRITICAL: Use factory method!
          }
      
      - step: "Add case to expression evaluator"
        file: "src/Interpreter/Interpreter.Expression.cs"
        location: "EvaluatePrimary() switch statement"
        code: |
          case TokenType.TOK_LOADSOUND:
              return EvaluateLoadSound();
  
  case_3_new_subsystem:
    description: "Adding entirely new functionality (Graphics, Sound, etc)"
    steps:
      - step: "Create manager class"
        location: "New folder: src/<Subsystem>/<Subsystem>Manager.cs"
        example: "src/Sound/SoundManager.cs"
      
      - step: "Add NuGet dependency if needed"
        file: "BazzBasic.csproj"
        code: '<PackageReference Include="NAudio" Version="2.2.1" />'
      
      - step: "Create interpreter partial class"
        file: "src/Interpreter/Interpreter.<Subsystem>.cs"
        example: "src/Interpreter/Interpreter.Sound.cs"
      
      - step: "Add manager instance to Interpreter.cs"
        file: "src/Interpreter/Interpreter.cs"
        code: "private readonly SoundManager _soundManager = new();"
      
      - step: "Implement all tokens following case_1/case_2 patterns"

# ============================================================================
# Critical Design Patterns
# ============================================================================

design_patterns:
  
  value_creation:
    rule: "NEVER use 'new Value()' directly"
    correct: |
      return Value.FromNumber(42);
      return Value.FromString("hello");
      return Value.Zero;  // 0
      return Value.Empty; // ""
    incorrect: |
      return new Value(42);        // COMPILE ERROR
      return new Value("hello");   // COMPILE ERROR
  
  token_consumption:
    rule: "Always advance _pos after reading token type"
    pattern: |
      private void ExecuteSomething()
      {
          _pos++; // Skip the TOK_SOMETHING token
          // ... rest of implementation
      }
  
  expression_parsing:
    rule: "Use EvaluateExpression() for any sub-expression"
    example: |
      // CORRECT: Parse any expression
      Value arg = EvaluateExpression();
      
      // WRONG: Manual token reading
      if (_tokens[_pos].Type == TokenType.TOK_NUMBER) { ... }
  
  parameter_handling:
    pattern_with_parens: |
      Require(TokenType.TOK_LPAREN, "Expected '('");
      Value arg1 = EvaluateExpression();
      Require(TokenType.TOK_COMMA, "Expected ','");
      Value arg2 = EvaluateExpression();
      Require(TokenType.TOK_RPAREN, "Expected ')'");
    
    pattern_optional_parens: |
      if (_pos < _tokens.Count && _tokens[_pos].Type == TokenType.TOK_LPAREN)
      {
          _pos++; // Skip '('
          Require(TokenType.TOK_RPAREN, "Expected ')'");
      }
  
  error_handling:
    rule: "Always include line number context"
    pattern: |
      throw new Exception($"Error at line {_tokens[_pos].LineNumber}: message");
    
    helper_method: |
      private void Require(TokenType expected, string message)
      {
          if (_pos >= _tokens.Count || _tokens[_pos].Type != expected)
              throw new Exception($"Line {GetCurrentLine()}: {message}");
          _pos++;
      }
  
  ide_winforms_patterns:
    sta_thread:
      rule: "IDE must run on STA thread for dialogs"
      pattern: |
        var thread = new Thread(() => {
            ApplicationConfiguration.Initialize();
            Application.Run(new MainForm());
        });
        thread.SetApartmentState(ApartmentState.STA);
        thread.Start();
        thread.Join();
    
    dialog_owner:
      rule: "Always pass owner to ShowDialog"
      pattern: "dialog.ShowDialog(this)"
    
    designer_compatibility:
      rule: "No lambdas in InitializeComponent"
      pattern: "Use separate WireEvents() method for event handlers"
    
    nullable_fields:
      rule: "Use = null! for fields initialized in InitializeComponent"
      pattern: "private TextBox myTextBox = null!;"

# ============================================================================
# Common Pitfalls & Solutions
# ============================================================================

common_mistakes:
  
  mistake_1:
    problem: "Value construction with 'new Value()'"
    symptom: "CS1729: 'Value' does not contain a constructor that takes 1 arguments"
    solution: "Use Value.FromNumber() or Value.FromString()"
    fix: |
      // WRONG
      return new Value(result);
      
      // CORRECT
      return Value.FromNumber(result);
  
  mistake_2:
    problem: "Forgetting to add 'using BazzBasic.Parser;'"
    symptom: "CS0246: The type or namespace name 'Value' could not be found"
    solution: "Add using directive to interpreter files"
    fix: |
      using BazzBasic.Lexer;
      using BazzBasic.Parser;  // REQUIRED for Value type
  
  mistake_3:
    problem: "Not advancing _pos after reading token"
    symptom: "Infinite loop or unexpected token errors"
    solution: "Always _pos++ after checking token type"
    fix: |
      private void ExecuteCommand()
      {
          _pos++; // CRITICAL: Consume the token!
          // ... rest
      }
  
  mistake_4:
    problem: "Manual token reading instead of EvaluateExpression()"
    symptom: "Complex expressions fail, operators not handled"
    solution: "Use EvaluateExpression() for all sub-expressions"
    fix: |
      // WRONG: Manual parsing
      Value x = new Value(_tokens[_pos].NumValue);
      
      // CORRECT: Use expression evaluator
      Value x = EvaluateExpression();
  
  mistake_5:
    problem: "Forgetting to add case to interpreter switch"
    symptom: "Token defined but never executed"
    solution: "Add case in Interpreter.cs ExecuteLine() or EvaluatePrimary()"
    checklist:
      - "Token in TokenType.cs?"
      - "Keyword in Lexer.cs dictionary?"
      - "Case in Interpreter.cs switch?"
      - "Handler method implemented?"
  
  mistake_6:
    problem: "Mixing statement and function tokens"
    symptom: "\"should be used as a function\" error or vice versa"
    solution: "Statements go in ExecuteLine(), functions in EvaluatePrimary()"
    rule: |
      // Statements (no return value): TOK_PRINT, TOK_SOUNDONCE
      case TOK_SOUNDONCE:
          ExecuteSoundOnce();
          break;
      
      // Functions (return Value): TOK_SIN, TOK_LOADSOUND
      case TOK_LOADSOUND:
          return EvaluateLoadSound();
  
  mistake_7:
    problem: "IDE file dialogs freeze/hang"
    symptom: "Dialog opens behind window or app freezes"
    solution: "Ensure STA thread and pass owner to ShowDialog"
    fix: |
      // In Program.cs - use STA thread
      thread.SetApartmentState(ApartmentState.STA);
      
      // In dialog calls - pass owner
      dialog.ShowDialog(this);
  
  mistake_8:
    problem: "Visual Studio Designer error in WinForms"
    symptom: "Designer cannot process code at line X"
    solution: "Move lambda event handlers to separate WireEvents() method"
    fix: |
      // WRONG: Lambda in InitializeComponent
      button.Click += (s, e) => DoSomething();
      
      // CORRECT: Separate method
      private void WireEvents() {
          button.Click += Button_Click;
      }
      private void Button_Click(object? sender, EventArgs e) {
          DoSomething();
      }

# ============================================================================
# Testing Patterns
# ============================================================================

testing:
  
  test_file_creation:
    location: "examples/"
    naming: "<feature>_test.bas"
    structure: |
      REM ============================================
      REM Test: <Feature Name>
      REM ============================================
      
      PRINT "Testing <feature>..."
      
      REM Test 1: Basic functionality
      <test code>
      
      REM Test 2: Edge cases
      <test code>
      
      REM Test 3: Error conditions
      <test code>
      
      PRINT "All tests passed!"
      END
  
  compilation_test:
    command: "dotnet build BazzBasic.csproj"
    location: "C:\\Users\\ekvir\\source\\repos\\BazzBasic"
  
  execution_test:
    command: "dotnet run -- examples/<test_file>.bas"
    location: "C:\\Users\\ekvir\\source\\repos\\BazzBasic"
  
  ide_test:
    command: "dotnet run"
    note: "No arguments launches IDE"
  
  typical_test_cases:
    - "Basic functionality with simple inputs"
    - "Multiple parameters and combinations"
    - "Edge cases (empty strings, zero, negative numbers)"
    - "Type conversion (string to number, number to string)"
    - "Error conditions (missing files, invalid parameters)"
    - "Integration with other features"

# ============================================================================
# Language Semantics - Important Rules
# ============================================================================

language_rules:
  
  variable_system:
    types:
      numeric: "Variables ending in nothing (e.g., x, count)"
      string: "Variables ending in $ (e.g., name$, text$)"
      constant: "Variables ending in # (e.g., PI#, MAX#)"
    
    declaration:
      required: true
      rule: "All variables must be declared with DIM before use"
      example: |
        DIM x          ' Numeric variable
        DIM name$      ' String variable
        DIM PI# = 3.14 ' Constant (immutable)
    
    scope:
      global: "Variables declared in main program"
      local: "Variables in function scope (isolated, cannot access globals)"
  
  array_system:
    features:
      - "Dynamic arrays (no fixed size)"
      - "String keys supported (associative arrays)"
      - "Mixed numeric/string indexing"
    
    example: |
      DIM arr(10)        ' Numeric index
      DIM dict$("key")   ' String key
      DIM mixed(0)       ' Can use both types
      mixed(5) = 100
      mixed("name") = "John"
  
  control_flow:
    if_statement:
      one_line: "IF condition THEN statement"
      multi_line: |
        IF condition THEN
            statements
        ELSEIF condition THEN
            statements  
        ELSE
            statements
        ENDIF
    
    loops:
      for: |
        FOR var = start TO end STEP increment
            statements
        NEXT
      
      while: |
        WHILE condition
            statements
        WEND
  
  functions:
    user_defined:
      syntax: |
        DEF FN name(param1, param2)
            statements
            RETURN value
        END DEF
      
      rules:
        - "Isolated scope - cannot access global variables"
        - "Must return a value"
        - "Parameters passed by value"

# ============================================================================
# External Dependencies
# ============================================================================

dependencies:
  nuget_packages:
    - name: "NAudio"
      version: "2.2.1"
      purpose: "Sound playback (LOADSOUND, SOUNDONCE, etc)"
      usage: "src/Sound/SoundManager.cs"
    
    - name: "Scintilla5.NET"
      version: "5.6.0"
      purpose: "IDE code editor with syntax highlighting"
      usage: "src/IDE/MainForm.cs"
  
  native_libraries:
    - name: "SDL2.dll"
      purpose: "Graphics rendering"
      deployment: "Copy to output directory"
  
  framework:
    target: ".NET 10"
    windows_forms: true
    features_used:
      - "C# 12 features"
      - "Partial classes for organization"
      - "Top-level statements in Program.cs"

# ============================================================================
# Quick Command Reference
# ============================================================================

commands:
  build:
    command: "dotnet build BazzBasic.csproj"
    directory: "C:\\Users\\ekvir\\source\\repos\\BazzBasic"
  
  run_ide:
    command: "dotnet run"
    directory: "C:\\Users\\ekvir\\source\\repos\\BazzBasic"
    note: "No arguments = launch IDE"
  
  run_interpreter:
    command: "dotnet run -- <file.bas>"
    directory: "C:\\Users\\ekvir\\source\\repos\\BazzBasic"
    example: "dotnet run -- examples/sound_test.bas"
  
  publish:
    command: "dotnet publish -c Release -r win-x64 --self-contained"
    note: "Creates single executable with runtime"
  
  search_codebase:
    tool: "Desktop Commander MCP"
    examples:
      - "start_search with pattern TOK_<keyword>"
      - "start_search with pattern Execute<Command>"
      - "start_search with searchType=content"

# ============================================================================
# Key Files Quick Reference
# ============================================================================

key_files:
  main_entry: "src/Program.cs"
  
  ide:
    main_form: "src/IDE/MainForm.cs"
    designer: "src/IDE/MainForm.Designer.cs"
    find_replace: "src/IDE/FindReplaceDialog.cs"
  
  lexer_core: "src/Lexer/Lexer.cs"
  tokens: "src/Lexer/TokenType.cs"
  
  value_type: "src/Parser/Value.cs"
  
  interpreter_main: "src/Interpreter/Interpreter.cs"
  interpreter_expressions: "src/Interpreter/Interpreter.Expression.cs"
  interpreter_control: "src/Interpreter/Interpreter.Control.cs"
  
  project_file: "BazzBasic.csproj"
  solution_file: "BazzBasic.NET.sln"

# ============================================================================
# AI Assistant Usage Tips
# ============================================================================

ai_assistant_tips:
  when_adding_feature:
    - "Read this file first for workflow"
    - "Follow appropriate case_1/case_2/case_3 pattern"
    - "Check common_mistakes before implementing"
    - "Create test file in examples/"
    - "Build and test incrementally"
  
  when_debugging:
    - "Check common_mistakes section first"
    - "Verify all 4 steps: TokenType → Lexer → Interpreter case → Handler"
    - "Look for missing 'using' directives"
    - "Confirm Value factory method usage"
  
  when_working_on_ide:
    - "Remember STA thread requirement"
    - "No lambdas in InitializeComponent - use WireEvents()"
    - "Use = null! for Designer fields"
    - "Pass 'this' to ShowDialog()"
    - "Test with both IDE and interpreter modes"
  
  when_learning_codebase:
    - "Start with architecture section"
    - "Review token_system for core mechanism"
    - "Study one feature_addition_workflow case"
    - "Look at existing Interpreter.*.cs files as examples"
  
  search_patterns:
    find_token_usage: "Search for 'TOK_<name>'"
    find_implementation: "Search for 'Execute<Name>' or 'Evaluate<Name>'"
    find_examples: "Look in examples/ directory"
    find_similar_feature: "Search existing Interpreter.*.cs files"

# ============================================================================
# Version History & Migration Notes
# ============================================================================

version_history:
  original:
    language: "Node.js"
    status: "Proof of concept, abandoned"
  
  v1:
    language: "FreeBASIC"
    status: "Working but deprecated"
    reason: "FreeBASIC stagnant, Windows 11 issues"
  
  v2_current:
    language: "C# .NET 10"
    status: "Active development"
    completed_features:
      - "Core BASIC language"
      - "Arrays with string keys"
      - "User-defined functions (DEF FN)"
      - "Control flow (IF/WHILE/FOR/GOSUB/GOTO)"
      - "Math functions"
      - "String functions"
      - "Graphics system (SDL2)"
      - "Sound system (NAudio)"
      - "Include directive preprocessor"
      - "Integrated IDE with Scintilla editor"
